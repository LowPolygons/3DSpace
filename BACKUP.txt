!gfortran -O2 -march=native vectors.F90 -o o2test
!test ./o2test

module vectorFunctions
	implicit none
contains
	function vectorAdd(v1, v2) result(ret_vector)
		implicit none
		real, dimension(1:3), intent(in) :: v1, v2
		real, dimension(1:3) :: ret_vector
		
		integer :: counter
		
		do counter = 1, 3
			ret_vector(counter) = v1(counter) + v2(counter)
		end do
		
	end function vectorAdd
	
	function vectorSub(v1, v2) result(ret_vector)
		implicit none
		real, dimension(1:3), intent(in) :: v1, v2
		real, dimension(1:3) :: ret_vector
		
		integer :: counter
		
		do counter = 1, 3
			ret_vector(counter) = v1(counter) - v2(counter)
		end do
		
	end function vectorSub

	function vectorMul(v1, v2) result(ret_vector)
		implicit none
		real, dimension(1:3), intent(in) :: v1, v2
		real, dimension(1:3) :: ret_vector
		
		integer :: counter
		
		do counter = 1, 3
			ret_vector(counter) = v1(counter) * v2(counter)
		end do
		
	end function vectorMul
	
	
	function vectorDiv(v1, v2) result(ret_vector)
		implicit none
		real, dimension(1:3), intent(in) :: v1, v2
		real, dimension(1:3) :: ret_vector
		
		integer :: counter
		
		do counter = 1, 3
			ret_vector(counter) = v1(counter) / v2(counter)
		end do
		
	end function vectorDiv
	
	function vectorMod(v1) result(ret_mod)
		implicit none
		real, dimension(1:3), intent(in) :: v1
		real :: ret_mod
		
		ret_mod = sqrt(v1(1)**2 + v1(2)**2 + v1(3)**2)
	end function vectorMod
	
end module vectorFunctions
!redundant

module boundaries
	use vectorFunctions
	implicit none
contains
	function checkBoundary(currPosAfterSim, lowerBound, upperBound) result(newPos)
		implicit none
		real, dimension(1:3), intent(in) :: currPosAfterSim, lowerBound, upperBound
		real, dimension(1:3) :: newPos
		real :: tempVariable
		!xyz handled separately as its smarter to do so	
		!x
		
		newPos = currPosAfterSim
		
		if (currPosAfterSim(1) < lowerBound(1)) then
			tempVariable = currPosAfterSim(1) - lowerBound(1)
			newPos(1) = upperBound(1) + tempVariable
		else if (currPosAfterSim(1) > upperBound(1)) then
			tempVariable = currPosAfterSim(1) - upperBound(1)
			newPos(1) = lowerBound(1) + tempVariable		
		end if	
		!y
		if (currPosAfterSim(2) < lowerBound(2)) then
			tempVariable = currPosAfterSim(2) - lowerBound(2)
			newPos(2) = upperBound(2) + tempVariable
		else if (currPosAfterSim(2) > upperBound(2)) then
			tempVariable = currPosAfterSim(2) - upperBound(2)
			newPos(2) = lowerBound(2) + tempVariable		
		end if
		!z
		if (currPosAfterSim(3) < lowerBound(3)) then
			tempVariable = currPosAfterSim(2) - lowerBound(3)
			newPos(3) = upperBound(3) + tempVariable
		else if (currPosAfterSim(3) > upperBound(3)) then
			tempVariable = currPosAfterSim(3) - upperBound(3)
			newPos(3) = lowerBound(3) + tempVariable		
		end if		
	end function checkBoundary
end module boundaries

program vectors
	use vectorFunctions
	use boundaries
	
	implicit none
	!y is considered up for this, though it doesnt matter really
	
	!this will be about establishing a 3D periodic space and allowing particles to move through it
	!the boundaries can be established simply by having a 2x3 array labelling a min and max coordinate
	!a logic suggestion would be to have a 1x3 and the origin is the lower boundary but just in case that causes
	!issues there is no point not having a lower bound
	!file i/o for the various parameters eventually
	
	!particles to be modelled a type containing their position and current velocity, which in the beginning can simply represent how much it moves per time step
	!alternative if this is a hassle is just a 1x6 array
	type particle
		real, dimension(3) :: currPos
		real, dimension(3) :: currVel
	end type particle
	
	real, dimension(3) :: lowerBound, upperBound
	integer :: timeSteps = 10000
	integer :: counter1, counter2, counter3
	real :: cutoff, randoVar
	integer :: pairInteractionsThisTick
	type(particle), dimension(10) :: particles

	integer, dimension(10) :: particlePairCount

	lowerBound = [0.0, 0.0, 0.0] !try keep as 0,0,0
	upperBound = [1.0, 1.0, 1.0]
	cutoff = 0.15

	do counter1 = 1, size(particles)
		call random_number(particles(counter1)%currPos)
		call random_number(particles(counter1)%currVel)
		particlePairCount(counter1) = 0
	end do


	1 format("Current Particle: ", i3, ", Current Pos: [", 3f12.10, "], Current Velocity: [", 3f12.10, "]")
	
	do counter1 = 1, timeSteps
		!first moves particles
		do counter2 = 1, size(particles)
			!print 1, counter2, particles(counter2)%currPos, particles(counter2)%currVel

			particles(counter2) = updateParticlePos(particles(counter2))
			particles(counter2)%currPos = checkBoundary(particles(counter2)%currPos, lowerBound, upperBound)

			!all to all loop rn of particle interacting with all other particles besides itself. Duplicate data will happen

			!print *, "Number of interactions this particle experienced this time step: ", pairInteractionsThisTick
			if (counter1 == timeSteps) then
				print 1, counter2, particles(counter2)%currPos, particles(counter2)%currVel	
				print "(/a1)", " "
			end if
		end do
		!now checks pairs
		do counter2 = 1, size(particles)
			do counter3 = 1, size(particles)
				if (counter3 /= counter2) then
					particlePairCount(counter2) = particlePairCount(counter2) + inRange(particles(counter2), particles(counter3), upperBound, &
					&lowerBound, cutoff)
				end if
			end do

			if (counter1 == timeSteps) then
				print *, "Number of interactions this particle experienced this time step: ", particlePairCount(counter2)
				print "(/a1)", " "
			end if
		end do
	end do
	
contains
	function updateParticlePos(part) result(ret_particle)
		implicit none
		
		type(particle), intent(in) :: part
		type(particle) :: ret_particle
		
		ret_particle%currPos = vectorAdd(part%currPos, part%currVel)
		ret_particle%currVel = part%currVel
		
	end function updateParticlePos

	function inRange(p1, p2, upperBound, lowerBound, cutoff) result(success)
		implicit none
		type(particle), intent(in) :: p1, p2
		real, dimension(1:3) :: upperBound, lowerBound
		real, intent(in) :: cutoff
		integer :: success
		real, dimension(1:3) :: temp
		logical, dimension(3,2) :: activeSpaces
		logical, dimension(-1:1,-1:1,-1:1) :: spaceMultipliers
		integer :: cX, cY, cZ
		!  xNeg xPos
		!  yNeg yPos
		!  zNeg zPos

		!first check if the mod of them is in cut off range
		!if it isnt, check if the cutoff goes into other spaces
		!get the position of other particle in those spaces and check the
		
		!going to assume that the lowerBound is 0,0,0 eventualyl will remove support for changing lower bound as it is not useful
		!therefore the position of the p2 particle is also the vector needed

		success = 0
	
		!the code above checls if the cut off region is in neighbouring spaces. 
		!The code below is going to check instead if it passes the corresponding X,Y,Z coordinate of the particle in that space
		
		!print *, spaceMultipliers(-1:1,  -1:1, -1:1)
!
		!!hopefully can reduce processing time		
		!if ((p1%currPos(1) - cutoff) >= (upperBound(1)+p2%currPos(1))) then
		!	spaceMultipliers( -1, -1:1, -1:1) = .true.
		!else
		!	spaceMultipliers( -1, -1:1, -1:1) = (spaceMultipliers(-1,-1:1,-1:1) .or. .false.)
		!end if
	!
		!if ((p1%currPos(1) + cutoff) >= (upperBound(1)+p2%currPos(1))) then
		!	spaceMultipliers( 1, -1:1, -1:1) = .true.
		!else
		!	spaceMultipliers( 1, -1:1, -1:1) = (spaceMultipliers( -1, -1:1, -1:1) .or. .false.)
		!end if	
!
		!if ((p1%currPos(2) - cutoff) <= (lowerBound(2)-p2%currPos(2))) then
		!	spaceMultipliers(-1:1, -1, -1:1) = .true.
		!else
		!	spaceMultipliers(-1:1, -1, -1:1) = (spaceMultipliers(-1:1, -1, -1:1) .or. .false.)
		!end if
		!
		!if ((p1%currPos(2) + cutoff) >= (upperBound(2)+p2%currPos(2))) then
		!	spaceMultipliers(-1:1,  1, -1:1) = .true.
		!else
		!	spaceMultipliers(-1:1,  1, -1:1) = (spaceMultipliers(-1:1,  1, -1:1) .or. .false.)
		!end if		
!
		!if ((p1%currPos(3) - cutoff) <= (lowerBound(3)-p2%currPos(3))) then
		!	spaceMultipliers(-1:1, -1:1, -1) = .true.
		!else
		!	spaceMultipliers(-1:1, -1:1, -1) = (spaceMultipliers(-1:1, -1:1, -1) .or. .false.)
		!end if
		!
		!if ((p1%currPos(3) + cutoff) >= (upperBound(3)+p2%currPos(3))) then
		!	spaceMultipliers(-1:1, -1:1,  1) = .true.
		!else
		!	spaceMultipliers(-1:1, -1:1,  1) = (spaceMultipliers(-1:1, -1:1,  1) .or. .false.)
		!end if
		

		!this code above establishes the planes which have particles within pair interaction distance
		!do it quick and dirty first

		!turn spaceMultipliers into the new activeSpaces woop do wee

		do cX = -1, 1, 1
			do cY = -1, 1, 1 
				do cZ = -1, 1, 1
					!if (spaceMultipliers(cX,cY,cZ)) then
						temp(1) = lowerBound(1) + cX*(upperBound(1)-lowerBound(1))
						temp(2) = lowerBound(2) + cY*(upperBound(2)-lowerBound(2))
						temp(3) = lowerBound(3) + cZ*(upperBound(3)-lowerBound(3))
						if (vectorMod(vectorSub(vectorAdd(temp, p2%currPos),p1%currPos)) <= cutoff) then
							!print *, vectorAdd(temp, p2%currPos), p1%currPos, vectorMod(vectorSub(vectorAdd(temp, p2%currPos),p1%currPos))
							success = success + 1
						end if		
					!end if		
				end do
			end do
		end do	

	end function inRange


end program vectors